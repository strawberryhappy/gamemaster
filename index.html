<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>モデルの一致率</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <style>
        #video {
            width: 100%;
            max-width: 600px;
        }
        #output {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>カメラ映像とモデルの一致率</h1>
    
    <!-- カメラ映像 -->
    <video id="video" autoplay playsinline></video>
    
    <!-- 結果表示 -->
    <div id="output"></div>

    <script>
        // モデルの読み込み
        async function loadModel() {
            // model.jsonのパスを修正（適切なパスを設定）
            const model = await tf.loadLayersModel('json/model.json'); 
            console.log("モデルが読み込まれました！");
            return model;
        }

        // カメラ映像の取得
        async function setupCamera() {
            const video = document.getElementById('video');
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 640, height: 480 }
            });
            video.srcObject = stream;
            return new Promise((resolve) => {
                video.onloadedmetadata = () => resolve(video);
            });
        }

        // 画像をモデルに合わせて前処理
        function preprocessFrame(frame) {
            const tensor = tf.browser.fromPixels(frame)
                .resizeNearestNeighbor([64, 64]) // モデルに合わせてリサイズ
                .toFloat()
                .div(tf.scalar(255)); // 正規化
            return tensor.expandDims(0); // バッチサイズを追加
        }

        // メイン処理
        async function run() {
            const model = await loadModel(); // モデルのロード
            const video = await setupCamera(); // カメラのセットアップ
            const outputDiv = document.getElementById('output');

            // 役職リスト
            const classNames = [
                "betrayer", "bodyguard", "citizen", "dictator", "fox", "god", "hunter", 
                "informer", "lovers", "necromancer", "prophet", "twins", "werewolf"
            ];

            // カメラ映像のフレームを定期的に取得して予測
            const predictFrame = async () => {
                const frame = tf.browser.fromPixels(video); // カメラフレームを取得
                const processedFrame = preprocessFrame(frame); // 前処理

                // モデルで予測
                const predictions = await model.predict(processedFrame);
                const predictionArray = predictions.dataSync(); // 結果を取得

                // 結果を表示
                outputDiv.innerHTML = "<h3>一致率:</h3>";
                predictionArray.forEach((confidence, index) => {
                    const className = classNames[index];
                    const confidencePercent = (confidence * 100).toFixed(2);
                    outputDiv.innerHTML += `<div>${className}: ${confidencePercent}%</div>`;
                });

                // 次のフレームを予測するために再帰的に呼び出し
                requestAnimationFrame(predictFrame);
            };

            // 予測の実行
            predictFrame();
        }

        // ページ読み込み後に実行
        run();
    </script>
</body>
</html>
